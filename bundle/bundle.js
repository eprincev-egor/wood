!function(t){var e={};function o(i){if(e[i])return e[i].exports;var n=e[i]={i:i,l:!1,exports:{}};return t[i].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=e,o.d=function(t,e,i){o.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},o.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},o.t=function(t,e){if(1&e&&(t=o(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(o.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)o.d(i,n,function(e){return t[e]}.bind(null,n));return i},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="",o(o.s=4)}([function(t,e,o){"use strict";const i=o(1);t.exports=class{constructor(){this.camera={x:0,y:0},this.trees=[],this.width=document.body.offsetWidth,this.height=document.body.offsetHeight,this.initCanvas(),this.initDrawer(),this.initKeyboard(),this.hasChange=!0,setInterval(()=>{this.main()},30)}main(){this.hasChange&&(this.generateArea(),this.draw(),this.hasChange=!1)}initCanvas(){const t=document.createElement("canvas");t.style.position="fixed",t.style.width="100%",t.style.height="100%",document.body.appendChild(t),this.canvas=t}initDrawer(){this.drawer=new i(this.canvas)}initKeyboard(){let{camera:t}=this;document.onkeydown=(e=>{37==e.keyCode&&(t.x-=10),38==e.keyCode&&(t.y-=10),39==e.keyCode&&(t.x+=10),40==e.keyCode&&(t.y+=10),this.hasChange=!0})}draw(){this.drawer.draw(this)}generateArea(){this.area||(this.area={}),this.trees=[];let{camera:t}=this;for(let e=t.x-this.width/2;e<t.x+this.width/2;e+=150)for(let o=t.y-this.height/2;o<t.y+this.height/2;o+=150){let t=e-e%150,i=o-o%150,n=t+":"+i,r=this.area[n];r||(r={x:t+150*Math.random(),y:i+150*Math.random()},this.area[n]=r),this.trees.push(r)}}}},function(t,e,o){"use strict";const i=o(2),n=o(3),r=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0];t.exports=class{constructor(t){let e=t.getContext("webgl");this.gl=e,this.canvas=t,this.vertexShader=i.createShader(e,e.VERTEX_SHADER,"\n            attribute vec4 a_position;\n            attribute vec3 a_normal;\n            \n            uniform vec3 u_lightWorldPosition;\n            uniform vec3 u_viewWorldPosition;\n            \n            uniform mat4 u_world;\n            uniform mat4 u_worldViewProjection;\n            uniform mat4 u_worldInverseTranspose;\n            \n            varying vec3 v_normal;\n            \n            varying vec3 v_surfaceToLight;\n            varying vec3 v_surfaceToView;\n            \n            void main() {\n            // Multiply the position by the matrix.\n            gl_Position = u_worldViewProjection * a_position;\n            \n            // orient the normals and pass to the fragment shader\n            v_normal = mat3(u_worldInverseTranspose) * a_normal;\n            \n            // compute the world position of the surface\n            vec3 surfaceWorldPosition = (u_world * a_position).xyz;\n            \n            // compute the vector of the surface to the light\n            // and pass it to the fragment shader\n            v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;\n            \n            // compute the vector of the surface to the view/camera\n            // and pass it to the fragment shader\n            v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;\n            }\n        "),this.fragmentShader=i.createShader(e,e.FRAGMENT_SHADER,"\n            precision mediump float;\n\n            // Passed in from the vertex shader.\n            varying vec3 v_normal;\n            varying vec3 v_surfaceToLight;\n            varying vec3 v_surfaceToView;\n            \n            uniform vec4 u_color;\n            uniform float u_shininess;\n            uniform vec3 u_lightDirection;\n            uniform float u_innerLimit;          // in dot space\n            uniform float u_outerLimit;          // in dot space\n            \n            void main() {\n            // because v_normal is a varying it's interpolated\n            // we it will not be a uint vector. Normalizing it\n            // will make it a unit vector again\n            vec3 normal = normalize(v_normal);\n            \n            vec3 surfaceToLightDirection = normalize(v_surfaceToLight);\n            vec3 surfaceToViewDirection = normalize(v_surfaceToView);\n            vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);\n            \n            float dotFromDirection = dot(surfaceToLightDirection,\n                                        -u_lightDirection);\n            float inLight = smoothstep(u_outerLimit, u_innerLimit, dotFromDirection);\n            float light = inLight * dot(normal, surfaceToLightDirection);\n            float specular = inLight * pow(dot(normal, halfVector), u_shininess);\n            \n            gl_FragColor = u_color;\n            \n            // Lets multiply just the color portion (not the alpha)\n            // by the light\n            gl_FragColor.rgb *= light;\n            \n            // Just add in the specular\n            gl_FragColor.rgb += specular;\n            }\n        ");let o=i.createProgram(e,this.vertexShader,this.fragmentShader);this.program=o,this.positionLocation=e.getAttribLocation(o,"a_position"),this.normalLocation=e.getAttribLocation(o,"a_normal"),this.colorLocation=e.getUniformLocation(o,"u_color"),this.worldViewProjectionLocation=e.getUniformLocation(o,"u_worldViewProjection"),this.worldInverseTransposeLocation=e.getUniformLocation(o,"u_worldInverseTranspose"),this.shininessLocation=e.getUniformLocation(o,"u_shininess"),this.lightDirectionLocation=e.getUniformLocation(o,"u_lightDirection"),this.innerLimitLocation=e.getUniformLocation(o,"u_innerLimit"),this.outerLimitLocation=e.getUniformLocation(o,"u_outerLimit"),this.lightWorldPositionLocation=e.getUniformLocation(o,"u_lightWorldPosition"),this.viewWorldPositionLocation=e.getUniformLocation(o,"u_viewWorldPosition"),this.worldLocation=e.getUniformLocation(o,"u_world");let a=n();this.treeInfo=a;let s=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,new Float32Array(a.points),e.STATIC_DRAW),this.positionBuffer=s;let c=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,c),e.bufferData(e.ARRAY_BUFFER,new Float32Array(r),e.STATIC_DRAW),this.normalBuffer=c}draw({trees:t,width:e,height:o}){let n,r,a,s,c,{canvas:l,gl:u,positionLocation:h,program:f,colorLocation:m,normalLocation:d,worldViewProjectionLocation:p,worldInverseTransposeLocation:g,shininessLocation:v,lightDirectionLocation:_,innerLimitLocation:w,outerLimitLocation:y,lightWorldPositionLocation:L,viewWorldPositionLocation:A,worldLocation:b,positionBuffer:P,normalBuffer:T,treeInfo:F}=this;l.width=e,l.height=o,u.viewport(0,0,e,o),u.clear(u.COLOR_BUFFER_BIT|u.DEPTH_BUFFER_BIT),u.enable(u.CULL_FACE),u.enable(u.DEPTH_TEST),u.useProgram(f),u.enableVertexAttribArray(h),u.bindBuffer(u.ARRAY_BUFFER,P),n=3,r=u.FLOAT,a=!1,s=0,c=0,u.vertexAttribPointer(h,n,r,a,s,c),u.enableVertexAttribArray(d),u.bindBuffer(u.ARRAY_BUFFER,T),n=3,r=u.FLOAT,a=!1,s=0,c=0,u.vertexAttribPointer(d,n,r,a,s,c);let R=u.canvas.clientWidth/u.canvas.clientHeight,x=i.perspective(60*Math.PI/180,R,1,2e3),M=[100,150,200],D=[0,35,0],S=[0,1,0],B=i.lookAt(M,D,S),C=i.inverse(B),E=i.multiply(x,C),U=i.yRotation(0),V=i.multiply(E,U),I=i.inverse(U),W=i.transpose(I);u.uniformMatrix4fv(p,!1,V),u.uniformMatrix4fv(g,!1,W),u.uniformMatrix4fv(b,!1,U),u.uniform4fv(m,[.2,1,.2,1]);const j=[40,60,120];u.uniform3fv(L,j),u.uniform3fv(A,M),u.uniform1f(v,150);let O=i.lookAt(j,D,S);O=i.multiply(i.xRotation(0),O);let k=[-(O=i.multiply(i.yRotation(0),O))[8],-O[9],-O[10]];u.uniform3fv(_,k),u.uniform1f(w,Math.cos(0)),u.uniform1f(y,Math.cos(25*Math.PI/180)),u.drawArrays(u.TRIANGLES,0,F.points.length/3)}}},function(t,e,o){"use strict";let i={createShader(t,e,o){let i=t.createShader(e);return t.shaderSource(i,o),t.compileShader(i),i},createProgram(t,e,o){let i=t.createProgram();return t.attachShader(i,e),t.attachShader(i,o),t.linkProgram(i),i},perspective(t,e,o,i){let n=Math.tan(.5*Math.PI-.5*t),r=1/(o-i);return[n/e,0,0,0,0,n,0,0,0,0,(o+i)*r,-1,0,0,o*i*r*2,0]},subtractVectors:(t,e,o)=>((o=o||new Float32Array(3))[0]=t[0]-e[0],o[1]=t[1]-e[1],o[2]=t[2]-e[2],o),xRotation(t,e){e=e||new Float32Array(16);let o=Math.cos(t),i=Math.sin(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=i,e[7]=0,e[8]=0,e[9]=-i,e[10]=o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},yRotation(t,e){e=e||new Float32Array(16);let o=Math.cos(t),i=Math.sin(t);return e[0]=o,e[1]=0,e[2]=-i,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=i,e[9]=0,e[10]=o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},transpose:(t,e)=>((e=e||new Float32Array(16))[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15],e),lookAt(t,e,o,n){n=n||new Float32Array(16);let r=i.normalize(i.subtractVectors(t,e)),a=i.normalize(i.cross(o,r)),s=i.normalize(i.cross(r,a));return n[0]=a[0],n[1]=a[1],n[2]=a[2],n[3]=0,n[4]=s[0],n[5]=s[1],n[6]=s[2],n[7]=0,n[8]=r[0],n[9]=r[1],n[10]=r[2],n[11]=0,n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n},cross:(t,e,o)=>((o=o||new Float32Array(3))[0]=t[1]*e[2]-t[2]*e[1],o[1]=t[2]*e[0]-t[0]*e[2],o[2]=t[0]*e[1]-t[1]*e[0],o),normalize(t,e){e=e||new Float32Array(3);let o=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return o>1e-5&&(e[0]=t[0]/o,e[1]=t[1]/o,e[2]=t[2]/o),e},multiply(t,e){let o=t[0],i=t[1],n=t[2],r=t[3],a=t[4],s=t[5],c=t[6],l=t[7],u=t[8],h=t[9],f=t[10],m=t[11],d=t[12],p=t[13],g=t[14],v=t[15],_=e[0],w=e[1],y=e[2],L=e[3],A=e[4],b=e[5],P=e[6],T=e[7],F=e[8],R=e[9],x=e[10],M=e[11],D=e[12],S=e[13],B=e[14],C=e[15];return[_*o+w*a+y*u+L*d,_*i+w*s+y*h+L*p,_*n+w*c+y*f+L*g,_*r+w*l+y*m+L*v,A*o+b*a+P*u+T*d,A*i+b*s+P*h+T*p,A*n+b*c+P*f+T*g,A*r+b*l+P*m+T*v,F*o+R*a+x*u+M*d,F*i+R*s+x*h+M*p,F*n+R*c+x*f+M*g,F*r+R*l+x*m+M*v,D*o+S*a+B*u+C*d,D*i+S*s+B*h+C*p,D*n+S*c+B*f+C*g,D*r+S*l+B*m+C*v]},translation:(t,e,o)=>[1,0,0,0,0,1,0,0,0,0,1,0,t,e,o,1],translate:(t,e,o,n)=>i.multiply(t,i.translation(e,o,n)),inverse(t){let e=t[0],o=t[1],i=t[2],n=t[3],r=t[4],a=t[5],s=t[6],c=t[7],l=t[8],u=t[9],h=t[10],f=t[11],m=t[12],d=t[13],p=t[14],g=t[15],v=h*g,_=p*f,w=s*g,y=p*c,L=s*f,A=h*c,b=i*g,P=p*n,T=i*f,F=h*n,R=i*c,x=s*n,M=l*d,D=m*u,S=r*d,B=m*a,C=r*u,E=l*a,U=e*d,V=m*o,I=e*u,W=l*o,j=e*a,O=r*o,k=v*a+y*u+L*d-(_*a+w*u+A*d),z=_*o+b*u+F*d-(v*o+P*u+T*d),H=w*o+P*a+R*d-(y*o+b*a+x*d),Y=A*o+T*a+x*u-(L*o+F*a+R*u),N=1/(e*k+r*z+l*H+m*Y);return[N*k,N*z,N*H,N*Y,N*(_*r+w*l+A*m-(v*r+y*l+L*m)),N*(v*e+P*l+T*m-(_*e+b*l+F*m)),N*(y*e+b*r+x*m-(w*e+P*r+R*m)),N*(L*e+F*r+R*l-(A*e+T*r+x*l)),N*(M*c+B*f+C*g-(D*c+S*f+E*g)),N*(D*n+U*f+W*g-(M*n+V*f+I*g)),N*(S*n+V*c+j*g-(B*n+U*c+O*g)),N*(E*n+I*c+O*f-(C*n+W*c+j*f)),N*(S*h+E*p+D*s-(C*p+M*s+B*h)),N*(I*p+M*i+V*h-(U*h+W*p+D*i)),N*(U*s+O*p+B*i-(j*p+S*i+V*s)),N*(j*h+C*i+W*s-(I*s+O*h+E*i))]}};t.exports=i},function(t,e,o){"use strict";t.exports=function(){let t=[],e=[],o=2*Math.PI/12,i=51,n=19,r=0,a=o;for(let s=0;s<12;s++){let s=10*Math.cos(r),c=10*Math.sin(r),l=10*Math.cos(a),u=10*Math.sin(a);t.push(s,c,-250),t.push(l,u,-250),t.push(0,0,-250),e.push(i,n,3,i,n,3,i,n,3),t.push(s,c,250),t.push(l,u,250),t.push(0,0,250),e.push(i,n,3,i,n,3,i,n,3),t.push(s,c,-250),t.push(l,u,-250),t.push(s,c,250),e.push(i,n,3,i,n,3,i,n,3),t.push(l,u,250),t.push(s,c,250),t.push(l,u,-250),e.push(i,n,3,i,n,3,i,n,3),r=a,a+=o}return{points:t,colors:e,normals:[]}}},function(t,e,o){o(0),o(1),o(2),o(5),t.exports=o(3)},function(t,e,o){"use strict";const i=o(0);setTimeout(()=>{window.app=new i})}]);