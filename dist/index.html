<script>!function(t){var e={};function o(i){if(e[i])return e[i].exports;var n=e[i]={i:i,l:!1,exports:{}};return t[i].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=e,o.d=function(t,e,i){o.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},o.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},o.t=function(t,e){if(1&e&&(t=o(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(o.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)o.d(i,n,function(e){return t[e]}.bind(null,n));return i},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="",o(o.s=4)}([function(t,e,o){"use strict";const i=o(1);t.exports=class{constructor(){this.camera={x:0,y:0},this.trees=[],this.width=document.body.offsetWidth,this.height=document.body.offsetHeight,this.initCanvas(),this.initDrawer(),this.initKeyboard(),this.hasChange=!0,setInterval(()=>{this.main()},30)}main(){this.hasChange&&(this.generateArea(),this.draw(),this.hasChange=!1)}initCanvas(){const t=document.createElement("canvas");t.style.position="fixed",t.style.width="100%",t.style.height="100%",document.body.appendChild(t),this.canvas=t}initDrawer(){this.drawer=new i(this.canvas)}initKeyboard(){let{camera:t}=this;document.onkeydown=(e=>{37==e.keyCode&&(t.x-=10),38==e.keyCode&&(t.y-=10),39==e.keyCode&&(t.x+=10),40==e.keyCode&&(t.y+=10),this.hasChange=!0})}draw(){this.drawer.draw(this)}generateArea(){this.area||(this.area={}),this.trees=[];let{camera:t}=this;for(let e=t.x-this.width/2;e<t.x+this.width/2;e+=150)for(let o=t.y-this.height/2;o<t.y+this.height/2;o+=150){let t=e-e%150,i=o-o%150,n=t+":"+i,r=this.area[n];r||(r={x:t+150*Math.random(),y:i+150*Math.random()},this.area[n]=r),this.trees.push(r)}}}},function(t,e,o){"use strict";const i=o(2),n=o(3);t.exports=class{constructor(t){let e=t.getContext("webgl");this.gl=e,this.canvas=t,this.vertexShader=i.createShader(e,e.VERTEX_SHADER,"\n            attribute vec4 a_position;\n            attribute vec3 a_normal;\n            \n            uniform vec3 u_lightWorldPosition;\n            uniform vec3 u_viewWorldPosition;\n            \n            uniform mat4 u_world;\n            uniform mat4 u_worldViewProjection;\n            uniform mat4 u_worldInverseTranspose;\n            \n            varying vec3 v_normal;\n            \n            varying vec3 v_surfaceToLight;\n            varying vec3 v_surfaceToView;\n            \n            void main() {\n            // Multiply the position by the matrix.\n            gl_Position = u_worldViewProjection * a_position;\n            \n            // orient the normals and pass to the fragment shader\n            v_normal = mat3(u_worldInverseTranspose) * a_normal;\n            \n            // compute the world position of the surface\n            vec3 surfaceWorldPosition = (u_world * a_position).xyz;\n            \n            // compute the vector of the surface to the light\n            // and pass it to the fragment shader\n            v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;\n            \n            // compute the vector of the surface to the view/camera\n            // and pass it to the fragment shader\n            v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;\n            }\n        "),this.fragmentShader=i.createShader(e,e.FRAGMENT_SHADER,"\n            precision mediump float;\n\n            // Passed in from the vertex shader.\n            varying vec3 v_normal;\n            varying vec3 v_surfaceToLight;\n            varying vec3 v_surfaceToView;\n            \n            uniform vec4 u_color;\n            uniform float u_shininess;\n            uniform vec3 u_lightDirection;\n            uniform float u_innerLimit;          // in dot space\n            uniform float u_outerLimit;          // in dot space\n            \n            void main() {\n            // because v_normal is a varying it's interpolated\n            // we it will not be a uint vector. Normalizing it\n            // will make it a unit vector again\n            vec3 normal = normalize(v_normal);\n            \n            vec3 surfaceToLightDirection = normalize(v_surfaceToLight);\n            vec3 surfaceToViewDirection = normalize(v_surfaceToView);\n            vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);\n            \n            float dotFromDirection = dot(surfaceToLightDirection,\n                                        -u_lightDirection);\n            float inLight = smoothstep(u_outerLimit, u_innerLimit, dotFromDirection);\n            float light = inLight * dot(normal, surfaceToLightDirection);\n            float specular = inLight * pow(dot(normal, halfVector), u_shininess);\n            \n            gl_FragColor = u_color;\n            \n            // Lets multiply just the color portion (not the alpha)\n            // by the light\n            gl_FragColor.rgb *= light;\n            \n            // Just add in the specular\n            gl_FragColor.rgb += specular;\n            }\n        ");let o=i.createProgram(e,this.vertexShader,this.fragmentShader);this.program=o,this.positionLocation=e.getAttribLocation(o,"a_position"),this.normalLocation=e.getAttribLocation(o,"a_normal"),this.colorLocation=e.getUniformLocation(o,"u_color"),this.worldViewProjectionLocation=e.getUniformLocation(o,"u_worldViewProjection"),this.worldInverseTransposeLocation=e.getUniformLocation(o,"u_worldInverseTranspose"),this.shininessLocation=e.getUniformLocation(o,"u_shininess"),this.lightDirectionLocation=e.getUniformLocation(o,"u_lightDirection"),this.innerLimitLocation=e.getUniformLocation(o,"u_innerLimit"),this.outerLimitLocation=e.getUniformLocation(o,"u_outerLimit"),this.lightWorldPositionLocation=e.getUniformLocation(o,"u_lightWorldPosition"),this.viewWorldPositionLocation=e.getUniformLocation(o,"u_viewWorldPosition"),this.worldLocation=e.getUniformLocation(o,"u_world");let r=n();this.treeInfo=r;let a=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,a),e.bufferData(e.ARRAY_BUFFER,new Float32Array(r.points),e.STATIC_DRAW),this.positionBuffer=a;let s=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,new Float32Array(r.normals),e.STATIC_DRAW),this.normalBuffer=s}draw({camera:t,trees:e,width:o,height:n}){let r,a,s,l,c,{canvas:h,gl:u,positionLocation:f,program:m,colorLocation:d,normalLocation:g,worldViewProjectionLocation:v,worldInverseTransposeLocation:p,shininessLocation:_,lightDirectionLocation:w,innerLimitLocation:y,outerLimitLocation:L,lightWorldPositionLocation:b,viewWorldPositionLocation:A,worldLocation:P,positionBuffer:T,normalBuffer:x,treeInfo:F}=this;h.width=o,h.height=n,u.viewport(0,0,o,n),u.clear(u.COLOR_BUFFER_BIT|u.DEPTH_BUFFER_BIT),u.enable(u.CULL_FACE),u.enable(u.DEPTH_TEST),u.useProgram(m),u.enableVertexAttribArray(f),u.bindBuffer(u.ARRAY_BUFFER,T),r=3,a=u.FLOAT,s=!1,l=0,c=0,u.vertexAttribPointer(f,r,a,s,l,c),u.enableVertexAttribArray(g),u.bindBuffer(u.ARRAY_BUFFER,x),r=3,a=u.FLOAT,s=!1,l=0,c=0,u.vertexAttribPointer(g,r,a,s,l,c);let R=u.canvas.clientWidth/u.canvas.clientHeight,M=i.perspective(60*Math.PI/180,R,1,2e3),D=i.translation(t.x,-t.y,400),S=i.inverse(D),B=i.multiply(M,S);u.uniform4fv(d,[1,1,1,1]);const C=[40,60,120];u.uniform3fv(b,C),u.uniform3fv(A,[t.x,t.y,0]),u.uniform1f(_,150);let E=i.lookAt(C,[0,35,0],[0,1,0]);E=i.multiply(i.xRotation(0),E);let U=[-(E=i.multiply(i.yRotation(0),E))[8],-E[9],-E[10]];u.uniform3fv(w,U),u.uniform1f(y,Math.cos(0)),u.uniform1f(L,Math.cos(25*Math.PI/180)),e.forEach(t=>{let e=i.yRotation(0);e=i.translate(e,t.x,t.y,0);let o=i.multiply(B,e),n=i.inverse(e),r=i.transpose(n);u.uniformMatrix4fv(v,!1,o),u.uniformMatrix4fv(p,!1,r),u.uniformMatrix4fv(P,!1,e),u.drawArrays(u.TRIANGLES,0,F.points.length/3)})}}},function(t,e,o){"use strict";let i={createShader(t,e,o){let i=t.createShader(e);return t.shaderSource(i,o),t.compileShader(i),i},createProgram(t,e,o){let i=t.createProgram();return t.attachShader(i,e),t.attachShader(i,o),t.linkProgram(i),i},perspective(t,e,o,i){let n=Math.tan(.5*Math.PI-.5*t),r=1/(o-i);return[n/e,0,0,0,0,n,0,0,0,0,(o+i)*r,-1,0,0,o*i*r*2,0]},subtractVectors:(t,e,o)=>((o=o||new Float32Array(3))[0]=t[0]-e[0],o[1]=t[1]-e[1],o[2]=t[2]-e[2],o),xRotation(t,e){e=e||new Float32Array(16);let o=Math.cos(t),i=Math.sin(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=i,e[7]=0,e[8]=0,e[9]=-i,e[10]=o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},yRotation(t,e){e=e||new Float32Array(16);let o=Math.cos(t),i=Math.sin(t);return e[0]=o,e[1]=0,e[2]=-i,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=i,e[9]=0,e[10]=o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},transpose:(t,e)=>((e=e||new Float32Array(16))[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15],e),lookAt(t,e,o,n){n=n||new Float32Array(16);let r=i.normalize(i.subtractVectors(t,e)),a=i.normalize(i.cross(o,r)),s=i.normalize(i.cross(r,a));return n[0]=a[0],n[1]=a[1],n[2]=a[2],n[3]=0,n[4]=s[0],n[5]=s[1],n[6]=s[2],n[7]=0,n[8]=r[0],n[9]=r[1],n[10]=r[2],n[11]=0,n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n},cross:(t,e,o)=>((o=o||new Float32Array(3))[0]=t[1]*e[2]-t[2]*e[1],o[1]=t[2]*e[0]-t[0]*e[2],o[2]=t[0]*e[1]-t[1]*e[0],o),normalize(t,e){e=e||new Float32Array(3);let o=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return o>1e-5&&(e[0]=t[0]/o,e[1]=t[1]/o,e[2]=t[2]/o),e},multiply(t,e){let o=t[0],i=t[1],n=t[2],r=t[3],a=t[4],s=t[5],l=t[6],c=t[7],h=t[8],u=t[9],f=t[10],m=t[11],d=t[12],g=t[13],v=t[14],p=t[15],_=e[0],w=e[1],y=e[2],L=e[3],b=e[4],A=e[5],P=e[6],T=e[7],x=e[8],F=e[9],R=e[10],M=e[11],D=e[12],S=e[13],B=e[14],C=e[15];return[_*o+w*a+y*h+L*d,_*i+w*s+y*u+L*g,_*n+w*l+y*f+L*v,_*r+w*c+y*m+L*p,b*o+A*a+P*h+T*d,b*i+A*s+P*u+T*g,b*n+A*l+P*f+T*v,b*r+A*c+P*m+T*p,x*o+F*a+R*h+M*d,x*i+F*s+R*u+M*g,x*n+F*l+R*f+M*v,x*r+F*c+R*m+M*p,D*o+S*a+B*h+C*d,D*i+S*s+B*u+C*g,D*n+S*l+B*f+C*v,D*r+S*c+B*m+C*p]},translation:(t,e,o)=>[1,0,0,0,0,1,0,0,0,0,1,0,t,e,o,1],translate:(t,e,o,n)=>i.multiply(t,i.translation(e,o,n)),inverse(t){let e=t[0],o=t[1],i=t[2],n=t[3],r=t[4],a=t[5],s=t[6],l=t[7],c=t[8],h=t[9],u=t[10],f=t[11],m=t[12],d=t[13],g=t[14],v=t[15],p=u*v,_=g*f,w=s*v,y=g*l,L=s*f,b=u*l,A=i*v,P=g*n,T=i*f,x=u*n,F=i*l,R=s*n,M=c*d,D=m*h,S=r*d,B=m*a,C=r*h,E=c*a,U=e*d,V=m*o,I=e*h,W=c*o,j=e*a,O=r*o,z=p*a+y*h+L*d-(_*a+w*h+b*d),k=_*o+A*h+x*d-(p*o+P*h+T*d),H=w*o+P*a+F*d-(y*o+A*a+R*d),Y=b*o+T*a+R*h-(L*o+x*a+F*h),N=1/(e*z+r*k+c*H+m*Y);return[N*z,N*k,N*H,N*Y,N*(_*r+w*c+b*m-(p*r+y*c+L*m)),N*(p*e+P*c+T*m-(_*e+A*c+x*m)),N*(y*e+A*r+R*m-(w*e+P*r+F*m)),N*(L*e+x*r+F*c-(b*e+T*r+R*c)),N*(M*l+B*f+C*v-(D*l+S*f+E*v)),N*(D*n+U*f+W*v-(M*n+V*f+I*v)),N*(S*n+V*l+j*v-(B*n+U*l+O*v)),N*(E*n+I*l+O*f-(C*n+W*l+j*f)),N*(S*u+E*g+D*s-(C*g+M*s+B*u)),N*(I*g+M*i+V*u-(U*u+W*g+D*i)),N*(U*s+O*g+B*i-(j*g+S*i+V*s)),N*(j*u+C*i+W*s-(I*s+O*u+E*i))]}};t.exports=i},function(t,e,o){"use strict";t.exports=function(){let t=[],e=[],o=[],i=2*Math.PI/12,n=51,r=19,a=0,s=i;for(let l=0;l<12;l++){let l=Math.cos(a),c=Math.sin(a),h=10*l,u=10*c,f=Math.cos(s),m=Math.sin(s),d=10*f,g=10*m;t.push(h,u,250,d,g,250,0,0,250),o.push(0,1,0,0,1,0,0,1,0),e.push(n,r,3,n,r,3,n,r,3),t.push(h,u,-250,d,g,-250,h,u,250,d,g,250,h,u,250,d,g,-250),o.push(l,c,0,f,m,0,l,c,0,f,m,0,l,c,0,f,m,0),e.push(n,r,3,n,r,3,n,r,3,n,r,3,n,r,3,n,r,3),a=s,s+=i}return{points:t,colors:e,normals:o}}},function(t,e,o){o(0),o(1),o(2),o(5),t.exports=o(3)},function(t,e,o){"use strict";const i=o(0);setTimeout(()=>{window.app=new i})}]);</script>