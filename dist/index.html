<script>!function(t){var e={};function o(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=e,o.d=function(t,e,r){o.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},o.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},o.t=function(t,e){if(1&e&&(t=o(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(o.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)o.d(r,n,function(e){return t[e]}.bind(null,n));return r},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="",o(o.s=4)}([function(t,e,o){"use strict";const r=o(1);t.exports=class{constructor(){this.camera={x:0,y:0},this.trees=[],this.area={},this.width=document.body.offsetWidth,this.height=document.body.offsetHeight,this.initCanvas(),this.initDrawer(),this.initKeyboard(),this.hasChange=!0,setInterval(()=>{this.main()},30)}main(){this.hasChange&&(this.generateArea(),this.draw(),this.hasChange=!1)}initCanvas(){const t=document.createElement("canvas");t.style.position="fixed",t.style.width="100%",t.style.height="100%",document.body.appendChild(t),this.canvas=t}initDrawer(){this.drawer=new r(this.canvas)}initKeyboard(){let{camera:t}=this;document.onkeydown=(e=>{37==e.keyCode&&(t.x-=10),38==e.keyCode&&(t.y+=10),39==e.keyCode&&(t.x+=10),40==e.keyCode&&(t.y-=10),this.hasChange=!0})}draw(){this.drawer.draw(this)}generateArea(){this.trees=[];let{camera:t,width:e,height:o,area:r}=this;for(let n=t.x-e/2;n<t.x+e/2;n+=150)for(let e=t.y-o/2;e<t.y+o/2;e+=150){let t=n-n%150,o=e-e%150,i=t+":"+o,a=r[i];a||(a={x:t+150*Math.random(),y:o+150*Math.random()},r[i]=a),this.trees.push(a)}}}},function(t,e,o){"use strict";const r=o(2),n=o(3);t.exports=class{constructor(t){let e=t.getContext("webgl");this.gl=e,this.canvas=t,this.vertexShader=r.createShader(e,e.VERTEX_SHADER,"\n            attribute vec4 a_position;\n            attribute vec3 a_normal;\n            \n            uniform vec3 u_lightWorldPosition;\n            uniform vec3 u_viewWorldPosition;\n            \n            uniform mat4 u_world;\n            uniform mat4 u_worldViewProjection;\n            uniform mat4 u_worldInverseTranspose;\n            \n            varying vec3 v_normal;\n            \n            varying vec3 v_surfaceToLight;\n            varying vec3 v_surfaceToView;\n            \n            void main() {\n            // Multiply the position by the matrix.\n            gl_Position = u_worldViewProjection * a_position;\n            \n            // orient the normals and pass to the fragment shader\n            v_normal = mat3(u_worldInverseTranspose) * a_normal;\n            \n            // compute the world position of the surface\n            vec3 surfaceWorldPosition = (u_world * a_position).xyz;\n            \n            // compute the vector of the surface to the light\n            // and pass it to the fragment shader\n            v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;\n            \n            // compute the vector of the surface to the view/camera\n            // and pass it to the fragment shader\n            v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;\n            }\n        "),this.fragmentShader=r.createShader(e,e.FRAGMENT_SHADER,"\n            precision mediump float;\n\n            // Passed in from the vertex shader.\n            varying vec3 v_normal;\n            varying vec3 v_surfaceToLight;\n            varying vec3 v_surfaceToView;\n            \n            uniform vec4 u_color;\n            uniform float u_shininess;\n            uniform vec3 u_lightDirection;\n            uniform float u_innerLimit;          // in dot space\n            uniform float u_outerLimit;          // in dot space\n            \n            void main() {\n            // because v_normal is a varying it's interpolated\n            // we it will not be a uint vector. Normalizing it\n            // will make it a unit vector again\n            vec3 normal = normalize(v_normal);\n            \n            vec3 surfaceToLightDirection = normalize(v_surfaceToLight);\n            vec3 surfaceToViewDirection = normalize(v_surfaceToView);\n            vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);\n            \n            float dotFromDirection = dot(surfaceToLightDirection,\n                                        -u_lightDirection);\n            float inLight = smoothstep(u_outerLimit, u_innerLimit, dotFromDirection);\n            float light = inLight * dot(normal, surfaceToLightDirection);\n            float specular = inLight * pow(dot(normal, halfVector), u_shininess);\n            \n            gl_FragColor = u_color;\n            \n            // Lets multiply just the color portion (not the alpha)\n            // by the light\n            gl_FragColor.rgb *= light;\n            \n            // Just add in the specular\n            gl_FragColor.rgb += specular;\n            }\n        ");let o=r.createProgram(e,this.vertexShader,this.fragmentShader);this.program=o,this.positionLocation=e.getAttribLocation(o,"a_position"),this.normalLocation=e.getAttribLocation(o,"a_normal"),this.colorLocation=e.getUniformLocation(o,"u_color"),this.worldViewProjectionLocation=e.getUniformLocation(o,"u_worldViewProjection"),this.worldInverseTransposeLocation=e.getUniformLocation(o,"u_worldInverseTranspose"),this.shininessLocation=e.getUniformLocation(o,"u_shininess"),this.lightDirectionLocation=e.getUniformLocation(o,"u_lightDirection"),this.innerLimitLocation=e.getUniformLocation(o,"u_innerLimit"),this.outerLimitLocation=e.getUniformLocation(o,"u_outerLimit"),this.lightWorldPositionLocation=e.getUniformLocation(o,"u_lightWorldPosition"),this.worldLocation=e.getUniformLocation(o,"u_world");let i=n();this.treeInfo=i,this.positionBuffer=e.createBuffer(),this.normalBuffer=e.createBuffer()}draw({camera:t,trees:e,width:o,height:n}){let i,a,s,c,l,{canvas:u,gl:h,positionLocation:f,program:m,colorLocation:d,normalLocation:g,worldViewProjectionLocation:v,worldInverseTransposeLocation:p,shininessLocation:_,lightDirectionLocation:y,innerLimitLocation:w,outerLimitLocation:L,lightWorldPositionLocation:A,worldLocation:b,positionBuffer:R,normalBuffer:F,treeInfo:x}=this;u.width=o,u.height=n,h.viewport(0,0,o,n),h.clear(h.COLOR_BUFFER_BIT|h.DEPTH_BUFFER_BIT),h.enable(h.CULL_FACE),h.enable(h.DEPTH_TEST),h.useProgram(m),h.enableVertexAttribArray(f),h.bindBuffer(h.ARRAY_BUFFER,R),i=3,a=h.FLOAT,s=!1,c=0,l=0,h.vertexAttribPointer(f,i,a,s,c,l),h.enableVertexAttribArray(g),h.bindBuffer(h.ARRAY_BUFFER,F),i=3,a=h.FLOAT,s=!1,c=0,l=0,h.vertexAttribPointer(g,i,a,s,c,l);let T=o/n,P=r.perspective(60*Math.PI/180,T,1,2e3),M=r.translation(t.x,t.y,400),D=r.inverse(M),B=r.multiply(P,D);h.uniform4fv(d,[81/256,107/256,130/256,1]);const S=[t.x,t.y,-230];h.uniform3fv(A,S),h.uniform1f(_,300);let E=S.slice();h.uniform3fv(y,E),h.uniform1f(w,Math.cos(20)),h.uniform1f(L,Math.cos(100*Math.PI/180));let C=r.yRotation(0),U=r.multiply(B,C),I=r.inverse(C),V=r.transpose(I);h.uniformMatrix4fv(v,!1,U),h.uniformMatrix4fv(p,!1,V),h.uniformMatrix4fv(b,!1,C),h.bindBuffer(h.ARRAY_BUFFER,R),h.bufferData(h.ARRAY_BUFFER,new Float32Array([t.x-o,t.y-n,-250,t.x+o,t.y-n,-250,t.x+o,t.y+n,-250,t.x-o,t.y-n,-250,t.x+o,t.y+n,-250,t.x-o,t.y+n,-250]),h.STATIC_DRAW),h.bindBuffer(h.ARRAY_BUFFER,F),h.bufferData(h.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1]),h.STATIC_DRAW),h.drawArrays(h.TRIANGLES,0,6),h.bindBuffer(h.ARRAY_BUFFER,R),h.bufferData(h.ARRAY_BUFFER,new Float32Array(x.points),h.STATIC_DRAW),h.bindBuffer(h.ARRAY_BUFFER,F),h.bufferData(h.ARRAY_BUFFER,new Float32Array(x.normals),h.STATIC_DRAW),e.forEach(t=>{let e=r.yRotation(0);e=r.translate(e,t.x,t.y,0);let o=r.multiply(B,e),n=r.inverse(e),i=r.transpose(n);h.uniformMatrix4fv(v,!1,o),h.uniformMatrix4fv(p,!1,i),h.uniformMatrix4fv(b,!1,e),h.drawArrays(h.TRIANGLES,0,x.points.length/3)})}}},function(t,e,o){"use strict";let r={createShader(t,e,o){let r=t.createShader(e);return t.shaderSource(r,o),t.compileShader(r),r},createProgram(t,e,o){let r=t.createProgram();return t.attachShader(r,e),t.attachShader(r,o),t.linkProgram(r),r},perspective(t,e,o,r){let n=Math.tan(.5*Math.PI-.5*t),i=1/(o-r);return[n/e,0,0,0,0,n,0,0,0,0,(o+r)*i,-1,0,0,o*r*i*2,0]},subtractVectors:(t,e,o)=>((o=o||new Float32Array(3))[0]=t[0]-e[0],o[1]=t[1]-e[1],o[2]=t[2]-e[2],o),xRotation(t,e){e=e||new Float32Array(16);let o=Math.cos(t),r=Math.sin(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},yRotation(t,e){e=e||new Float32Array(16);let o=Math.cos(t),r=Math.sin(t);return e[0]=o,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},transpose:(t,e)=>((e=e||new Float32Array(16))[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15],e),lookAt(t,e,o,n){n=n||new Float32Array(16);let i=r.normalize(r.subtractVectors(t,e)),a=r.normalize(r.cross(o,i)),s=r.normalize(r.cross(i,a));return n[0]=a[0],n[1]=a[1],n[2]=a[2],n[3]=0,n[4]=s[0],n[5]=s[1],n[6]=s[2],n[7]=0,n[8]=i[0],n[9]=i[1],n[10]=i[2],n[11]=0,n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n},cross:(t,e,o)=>((o=o||new Float32Array(3))[0]=t[1]*e[2]-t[2]*e[1],o[1]=t[2]*e[0]-t[0]*e[2],o[2]=t[0]*e[1]-t[1]*e[0],o),normalize(t,e){e=e||new Float32Array(3);let o=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return o>1e-5&&(e[0]=t[0]/o,e[1]=t[1]/o,e[2]=t[2]/o),e},multiply(t,e){let o=t[0],r=t[1],n=t[2],i=t[3],a=t[4],s=t[5],c=t[6],l=t[7],u=t[8],h=t[9],f=t[10],m=t[11],d=t[12],g=t[13],v=t[14],p=t[15],_=e[0],y=e[1],w=e[2],L=e[3],A=e[4],b=e[5],R=e[6],F=e[7],x=e[8],T=e[9],P=e[10],M=e[11],D=e[12],B=e[13],S=e[14],E=e[15];return[_*o+y*a+w*u+L*d,_*r+y*s+w*h+L*g,_*n+y*c+w*f+L*v,_*i+y*l+w*m+L*p,A*o+b*a+R*u+F*d,A*r+b*s+R*h+F*g,A*n+b*c+R*f+F*v,A*i+b*l+R*m+F*p,x*o+T*a+P*u+M*d,x*r+T*s+P*h+M*g,x*n+T*c+P*f+M*v,x*i+T*l+P*m+M*p,D*o+B*a+S*u+E*d,D*r+B*s+S*h+E*g,D*n+B*c+S*f+E*v,D*i+B*l+S*m+E*p]},translation:(t,e,o)=>[1,0,0,0,0,1,0,0,0,0,1,0,t,e,o,1],translate:(t,e,o,n)=>r.multiply(t,r.translation(e,o,n)),inverse(t){let e=t[0],o=t[1],r=t[2],n=t[3],i=t[4],a=t[5],s=t[6],c=t[7],l=t[8],u=t[9],h=t[10],f=t[11],m=t[12],d=t[13],g=t[14],v=t[15],p=h*v,_=g*f,y=s*v,w=g*c,L=s*f,A=h*c,b=r*v,R=g*n,F=r*f,x=h*n,T=r*c,P=s*n,M=l*d,D=m*u,B=i*d,S=m*a,E=i*u,C=l*a,U=e*d,I=m*o,V=e*u,W=l*o,j=e*a,O=i*o,z=p*a+w*u+L*d-(_*a+y*u+A*d),Y=_*o+b*u+x*d-(p*o+R*u+F*d),k=y*o+R*a+T*d-(w*o+b*a+P*d),H=A*o+F*a+P*u-(L*o+x*a+T*u),N=1/(e*z+i*Y+l*k+m*H);return[N*z,N*Y,N*k,N*H,N*(_*i+y*l+A*m-(p*i+w*l+L*m)),N*(p*e+R*l+F*m-(_*e+b*l+x*m)),N*(w*e+b*i+P*m-(y*e+R*i+T*m)),N*(L*e+x*i+T*l-(A*e+F*i+P*l)),N*(M*c+S*f+E*v-(D*c+B*f+C*v)),N*(D*n+U*f+W*v-(M*n+I*f+V*v)),N*(B*n+I*c+j*v-(S*n+U*c+O*v)),N*(C*n+V*c+O*f-(E*n+W*c+j*f)),N*(B*h+C*g+D*s-(E*g+M*s+S*h)),N*(V*g+M*r+I*h-(U*h+W*g+D*r)),N*(U*s+O*g+S*r-(j*g+B*r+I*s)),N*(j*h+E*r+W*s-(V*s+O*h+C*r))]}};t.exports=r},function(t,e,o){"use strict";t.exports=function(){let t=[],e=[],o=[],r=2*Math.PI/12,n=51,i=19,a=0,s=r;for(let c=0;c<12;c++){let c=Math.cos(a),l=Math.sin(a),u=10*c,h=10*l,f=Math.cos(s),m=Math.sin(s),d=10*f,g=10*m;t.push(u,h,250,d,g,250,0,0,250),o.push(0,1,0,0,1,0,0,1,0),e.push(n,i,3,n,i,3,n,i,3),t.push(u,h,-250,d,g,-250,u,h,250,d,g,250,u,h,250,d,g,-250),o.push(c,l,0,f,m,0,c,l,0,f,m,0,c,l,0,f,m,0),e.push(n,i,3,n,i,3,n,i,3,n,i,3,n,i,3,n,i,3),a=s,s+=r}return{points:t,colors:e,normals:o}}},function(t,e,o){o(0),o(1),o(2),o(5),t.exports=o(3)},function(t,e,o){"use strict";const r=o(0);setTimeout(()=>{window.app=new r})}]);</script>