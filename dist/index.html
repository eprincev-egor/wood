<html><head><meta charset="UTF-8"></head><body><script>!function(t){var e={};function r(o){if(e[o])return e[o].exports;var i=e[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,r),i.l=!0,i.exports}r.m=t,r.c=e,r.d=function(t,e,o){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(o,i,function(e){return t[e]}.bind(null,i));return o},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=3)}([function(t,e,r){"use strict";const o=r(1);let i=+localStorage.getItem("recordScore")||0;t.exports=class{constructor(){this.camera={},this.cable=[];let t=document.createElement("style");t.innerHTML="* {margin: 0; padding: 0; overflow: hidden;} html, body {width: 100%; height: 100%;}",document.body.appendChild(t),this.width=document.body.offsetWidth,this.height=document.body.offsetHeight,this.clearState(),this.initKeyboard(),this.initCanvas(),this.initDrawer(),this.initScore(),this.initCenterEl(),this.start()}clearState(){this.camera.x=0,this.camera.y=0,this.trees=[],this.area={},this.score=0,this.cable.length=0,this.cable.push({x:0,y:-this.height/2}),this.cable.push({x:0,y:0})}initScore(){let t=document.createElement("div"),e=t.style;e.top="10px",e.left="10px",e.fontSize="18px",e.fontFamily="Arial",e.fontWeight="bold",e.position="absolute",e.color="white",document.body.appendChild(t),this.scoreEl=t}start(){this.interval=setInterval(()=>{this.main()},30)}stop(){clearInterval(this.interval)}restart(){this.stop(),this.clearState(),this.start()}main(){let{camera:t,keyCodes:e}=this,r=10,o=0,n=1;if(e.up&&(n=1,r=30),e.down&&(n=-1),e.left&&(o=-1),e.right&&(o=1),0!=o||0!=n){let e=Math.sqrt(o*o+n*n),a=t.x+r*o/e,s=t.y+r*n/e;if(this.trees.some(t=>{let e=a-t.x,r=s-t.y;return Math.sqrt(e*e+r*r)<25}))return this.stop(),void(this.score>i?(i=this.score,localStorage.setItem("recordScore",i),this.showRecord(()=>{this.clearState(),this.start()})):this.showGameOver(()=>{this.clearState(),this.start()}));t.x=a,t.y=s;let l=this.cable.slice(-1)[0];l.x==a||l.y==s?(l.x=a,l.y=s):this.cable.push({x:a,y:s}),this.score+=e}this.generateArea(),this.draw()}initCanvas(){const t=document.createElement("canvas");t.style.position="fixed",t.style.width="100%",t.style.height="100%",document.body.appendChild(t),this.canvas=t}initDrawer(){this.drawer=new o(this.canvas)}initKeyboard(){let t={up:!1,down:!1,left:!1,right:!1};this.keyCodes=t,document.onkeyup=(e=>{37==e.keyCode&&(t.left=!1),38==e.keyCode&&(t.up=!1),39==e.keyCode&&(t.right=!1),40==e.keyCode&&(t.down=!1)}),document.onkeydown=(e=>{37==e.keyCode&&(t.left=!0),38==e.keyCode&&(t.up=!0),39==e.keyCode&&(t.right=!0),40==e.keyCode&&(t.down=!0)})}draw(){this.drawer.draw(this),this.drawScore()}drawScore(){this.scoreEl.innerHTML=Math.floor(this.score)}generateArea(){this.trees=[];let{camera:t,width:e,height:r,area:o}=this;for(let i=t.x-e/2;i<t.x+e/2;i+=175)for(let e=t.y-r/2;e<t.y+r/2;e+=175){let t=i-i%175,n=e-e%175,a=t+":"+n,s=o[a];t>=-175&&t<=175&&n<=r/4&&n>=-r/2||(s||(s={x:t+10+165*Math.random(),y:n+10+165*Math.random()},o[a]=s),this.trees.push(s))}}initCenterEl(){let t=document.createElement("div"),e=t.style;e.top="calc( 50% - 10px )",e.left="10px",e.width="100%",e.fontSize="36px",e.fontFamily="Arial",e.fontWeight="bold",e.position="absolute",e.color="white",e.opacity="1",e.textAlign="center",e.transition="all .5s",document.body.appendChild(t),this.centerEl=t}showRecord(t){clearTimeout(this.timer),this.centerEl.innerHTML="RECORD: "+Math.floor(i),this.centerEl.style.opacity=1,this.timer=setTimeout(()=>{this.centerEl.style.opacity=0,this.timer=setTimeout(()=>{this.centerEl.innerHTML="",t&&t()},2e3)},2e3)}showGameOver(t){clearTimeout(this.timer),this.centerEl.innerHTML="OFFLINE",this.centerEl.style.opacity=1,this.timer=setTimeout(()=>{this.centerEl.style.opacity=0,this.timer=setTimeout(()=>{this.centerEl.innerHTML="",t&&t()},1e3)},1e3)}}},function(t,e,r){"use strict";const o=r(2);t.exports=class{constructor(t){let e=t.getContext("webgl");this.gl=e,this.canvas=t,this.vertexShader=o.createShader(e,e.VERTEX_SHADER,"\n            attribute vec4 a_position;\n            attribute vec3 a_normal;\n            \n            uniform vec3 u_lightWorldPosition;\n            \n            uniform mat4 u_world;\n            uniform mat4 u_worldViewProjection;\n            uniform mat4 u_worldInverseTranspose;\n            \n            varying vec3 v_normal;\n            \n            varying vec3 v_surfaceToLight;\n            \n            void main() {\n                // Multiply the position by the matrix.\n                gl_Position = u_worldViewProjection * a_position;\n                \n                // orient the normals and pass to the fragment shader\n                v_normal = mat3(u_worldInverseTranspose) * a_normal;\n                \n                // compute the world position of the surfoace\n                vec3 surfaceWorldPosition = (u_world * a_position).xyz;\n                \n                // compute the vector of the surface to the light\n                // and pass it to the fragment shader\n                v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;\n            }\n        "),this.fragmentShader=o.createShader(e,e.FRAGMENT_SHADER,"\n            precision mediump float;\n\n            // Passed in from the vertex shader.\n            varying vec3 v_normal;\n            varying vec3 v_surfaceToLight;\n            \n            uniform vec4 u_color;\n            \n            void main() {\n                // because v_normal is a varying it's interpolated\n                // we it will not be a uint vector. Normalizing it\n                // will make it a unit vector again\n                vec3 normal = normalize(v_normal);\n                \n                vec3 surfaceToLightDirection = normalize(v_surfaceToLight);\n                \n                float light = dot(normal, surfaceToLightDirection);\n                \n                gl_FragColor = u_color;\n                \n                // Lets multiply just the color portion (not the alpha)\n                // by the light\n                gl_FragColor.rgb *= light;\n            }\n        ");let r=o.createProgram(e,this.vertexShader,this.fragmentShader);this.program=r,this.positionLocation=e.getAttribLocation(r,"a_position"),this.normalLocation=e.getAttribLocation(r,"a_normal"),this.worldViewProjectionLocation=e.getUniformLocation(r,"u_worldViewProjection"),this.worldInverseTransposeLocation=e.getUniformLocation(r,"u_worldInverseTranspose"),this.lightWorldPositionLocation=e.getUniformLocation(r,"u_lightWorldPosition"),this.worldLocation=e.getUniformLocation(r,"u_world");let i=o.cylinder({});this.treeInfo=i,this.positionBuffer=e.createBuffer(),this.normalBuffer=e.createBuffer()}draw({camera:t,trees:e,width:r,height:i,cable:n}){let a,s,l,c,h,{canvas:u,gl:d,positionLocation:f,program:m,normalLocation:p,worldViewProjectionLocation:y,worldInverseTransposeLocation:g,lightWorldPositionLocation:v,worldLocation:A,positionBuffer:w,normalBuffer:b,treeInfo:_}=this;u.width=r,u.height=i,d.viewport(0,0,r,i),d.clear(d.COLOR_BUFFER_BIT|d.DEPTH_BUFFER_BIT),d.enable(d.CULL_FACE),d.enable(d.DEPTH_TEST),d.useProgram(m),d.enableVertexAttribArray(f),d.bindBuffer(d.ARRAY_BUFFER,w),a=3,s=d.FLOAT,l=!1,c=0,h=0,d.vertexAttribPointer(f,a,s,l,c,h),d.enableVertexAttribArray(p),d.bindBuffer(d.ARRAY_BUFFER,b),a=3,s=d.FLOAT,l=!1,c=0,h=0,d.vertexAttribPointer(p,a,s,l,c,h);let R=r/i,x=o.perspective(60*Math.PI/180,R,1,2e3),F=o.translation(t.x,t.y,400),T=o.inverse(F),E=o.multiply(x,T);const M=[t.x,t.y,-230];d.uniform3fv(v,M);let S=o.translation(t.x,t.y,0),L=o.multiply(E,S),B=o.inverse(S),P=o.transpose(B);d.uniformMatrix4fv(y,!1,L),d.uniformMatrix4fv(g,!1,P),d.uniformMatrix4fv(A,!1,S),d.bindBuffer(d.ARRAY_BUFFER,w),d.bufferData(d.ARRAY_BUFFER,new Float32Array([-r,-i,-250,+r,-i,-250,+r,+i,-250,-r,-i,-250,+r,+i,-250,-r,+i,-250]),d.STATIC_DRAW),d.bindBuffer(d.ARRAY_BUFFER,b),d.bufferData(d.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1]),d.STATIC_DRAW),d.drawArrays(d.TRIANGLES,0,6),S=o.translation(0,0,0),L=o.multiply(E,S),B=o.inverse(S),P=o.transpose(B),d.uniformMatrix4fv(y,!1,L),d.uniformMatrix4fv(g,!1,P),d.uniformMatrix4fv(A,!1,S);let C=[],I=[],D=n.slice(-50);for(let t=1,e=D.length;t<e;t++){let e=D[t],r=D[t-1],i=o.cableSegment({fromX:r.x,fromY:r.y,toX:e.x,toY:e.y});I=(C=C.concat(i.points)).concat(i.normals)}d.bindBuffer(d.ARRAY_BUFFER,w),d.bufferData(d.ARRAY_BUFFER,new Float32Array(C),d.STATIC_DRAW),d.bindBuffer(d.ARRAY_BUFFER,b),d.bufferData(d.ARRAY_BUFFER,new Float32Array(I),d.STATIC_DRAW),d.drawArrays(d.TRIANGLES,0,C.length/3),d.bindBuffer(d.ARRAY_BUFFER,w),d.bufferData(d.ARRAY_BUFFER,new Float32Array(_.points),d.STATIC_DRAW),d.bindBuffer(d.ARRAY_BUFFER,b),d.bufferData(d.ARRAY_BUFFER,new Float32Array(_.normals),d.STATIC_DRAW),e.forEach(t=>{let e=o.translation(t.x,t.y,0),r=o.multiply(E,e),i=o.inverse(e),n=o.transpose(i);d.uniformMatrix4fv(y,!1,r),d.uniformMatrix4fv(g,!1,n),d.uniformMatrix4fv(A,!1,e),d.drawArrays(d.TRIANGLES,0,_.points.length/3)})}}},function(t,e,r){"use strict";let o={createShader(t,e,r){let o=t.createShader(e);return t.shaderSource(o,r),t.compileShader(o),o},createProgram(t,e,r){let o=t.createProgram();return t.attachShader(o,e),t.attachShader(o,r),t.linkProgram(o),o},perspective(t,e,r,o){let i=Math.tan(.5*Math.PI-.5*t),n=1/(r-o);return[i/e,0,0,0,0,i,0,0,0,0,(r+o)*n,-1,0,0,r*o*n*2,0]},subtractVectors:(t,e,r)=>((r=r||new Float32Array(3))[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],r),xRotation(t,e){e=e||new Float32Array(16);let r=Math.cos(t),o=Math.sin(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=o,e[7]=0,e[8]=0,e[9]=-o,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},yRotation(t,e){e=e||new Float32Array(16);let r=Math.cos(t),o=Math.sin(t);return e[0]=r,e[1]=0,e[2]=-o,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=o,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},transpose:(t,e)=>((e=e||new Float32Array(16))[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15],e),lookAt(t,e,r,i){i=i||new Float32Array(16);let n=o.normalize(o.subtractVectors(t,e)),a=o.normalize(o.cross(r,n)),s=o.normalize(o.cross(n,a));return i[0]=a[0],i[1]=a[1],i[2]=a[2],i[3]=0,i[4]=s[0],i[5]=s[1],i[6]=s[2],i[7]=0,i[8]=n[0],i[9]=n[1],i[10]=n[2],i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},cross:(t,e,r)=>((r=r||new Float32Array(3))[0]=t[1]*e[2]-t[2]*e[1],r[1]=t[2]*e[0]-t[0]*e[2],r[2]=t[0]*e[1]-t[1]*e[0],r),normalize(t,e){e=e||new Float32Array(3);let r=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return r>1e-5&&(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r),e},multiply(t,e){let r=t[0],o=t[1],i=t[2],n=t[3],a=t[4],s=t[5],l=t[6],c=t[7],h=t[8],u=t[9],d=t[10],f=t[11],m=t[12],p=t[13],y=t[14],g=t[15],v=e[0],A=e[1],w=e[2],b=e[3],_=e[4],R=e[5],x=e[6],F=e[7],T=e[8],E=e[9],M=e[10],S=e[11],L=e[12],B=e[13],P=e[14],C=e[15];return[v*r+A*a+w*h+b*m,v*o+A*s+w*u+b*p,v*i+A*l+w*d+b*y,v*n+A*c+w*f+b*g,_*r+R*a+x*h+F*m,_*o+R*s+x*u+F*p,_*i+R*l+x*d+F*y,_*n+R*c+x*f+F*g,T*r+E*a+M*h+S*m,T*o+E*s+M*u+S*p,T*i+E*l+M*d+S*y,T*n+E*c+M*f+S*g,L*r+B*a+P*h+C*m,L*o+B*s+P*u+C*p,L*i+B*l+P*d+C*y,L*n+B*c+P*f+C*g]},translation:(t,e,r)=>[1,0,0,0,0,1,0,0,0,0,1,0,t,e,r,1],translate:(t,e,r,i)=>o.multiply(t,o.translation(e,r,i)),inverse(t){let e=t[0],r=t[1],o=t[2],i=t[3],n=t[4],a=t[5],s=t[6],l=t[7],c=t[8],h=t[9],u=t[10],d=t[11],f=t[12],m=t[13],p=t[14],y=t[15],g=u*y,v=p*d,A=s*y,w=p*l,b=s*d,_=u*l,R=o*y,x=p*i,F=o*d,T=u*i,E=o*l,M=s*i,S=c*m,L=f*h,B=n*m,P=f*a,C=n*h,I=c*a,D=e*m,U=f*r,Y=e*h,W=c*r,k=e*a,O=n*r,j=g*a+w*h+b*m-(v*a+A*h+_*m),H=v*r+R*h+T*m-(g*r+x*h+F*m),z=A*r+x*a+E*m-(w*r+R*a+M*m),V=_*r+F*a+M*h-(b*r+T*a+E*h),G=1/(e*j+n*H+c*z+f*V);return[G*j,G*H,G*z,G*V,G*(v*n+A*c+_*f-(g*n+w*c+b*f)),G*(g*e+x*c+F*f-(v*e+R*c+T*f)),G*(w*e+R*n+M*f-(A*e+x*n+E*f)),G*(b*e+T*n+E*c-(_*e+F*n+M*c)),G*(S*l+P*d+C*y-(L*l+B*d+I*y)),G*(L*i+D*d+W*y-(S*i+U*d+Y*y)),G*(B*i+U*l+k*y-(P*i+D*l+O*y)),G*(I*i+Y*l+O*d-(C*i+W*l+k*d)),G*(B*u+I*p+L*s-(C*p+S*s+P*u)),G*(Y*p+S*o+U*u-(D*u+W*p+L*o)),G*(D*s+O*p+P*o-(k*p+B*o+U*s)),G*(k*u+C*o+W*s-(Y*s+O*u+I*o))]},cylinder({length:t=500,radius:e=10}){let r=[],o=[],i=2*Math.PI/12,n=t/2,a=0,s=i;for(let t=0;t<12;t++){let t=Math.cos(a),l=Math.sin(a),c=e*t,h=e*l,u=Math.cos(s),d=Math.sin(s),f=e*u,m=e*d;r.push(c,h,n,f,m,n,0,0,n),o.push(0,1,0,0,1,0,0,1,0),r.push(c,h,-n,f,m,-n,c,h,n,f,m,n,c,h,n,f,m,-n),o.push(t,l,0,u,d,0,t,l,0,u,d,0,t,l,0,u,d,0),a=s,s+=i}return{points:r,normals:o}},cableSegment({fromX:t,fromY:e,toX:r,toY:o}){let i=[],n=[],a=-240,s=2*Math.PI/12,l=r-t,c=o-e,h=Math.sqrt(l*l+c*c),u=Math.ceil(h/5),d=l/u,f=c/u,m=t,p=e;for(let t=0;t<u;t++){let t=0,e=s;for(let r=0;r<12;r++){let r=5*Math.cos(t),o=5*Math.sin(t),l=5*Math.cos(e),c=5*Math.sin(e);i.push(m+r,p+o,a,m+l,p+c,a,m,p,a),n.push(1,1,0,1,1,0,1,1,0),t=e,e+=s}m+=d,p+=f}return{points:i,normals:n}}};t.exports=o},function(t,e,r){r(0),r(1),r(2),t.exports=r(4)},function(t,e,r){"use strict";const o=r(0);setTimeout(()=>{window.app=new o})}]);</script></body></html>